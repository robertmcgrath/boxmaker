/* *	A wrapper for PSGr to draw boxes.  Initialize, then call drawBox! * *	2004.03.10 (rahulb) *		- created, gleaning code out of BoxMaker.java */package com.rahulbotics.boxmaker;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.util.Date;import com.lowagie.text.Document;import com.lowagie.text.DocumentException;import com.lowagie.text.Paragraph;import com.lowagie.text.Rectangle;import com.lowagie.text.pdf.BaseFont;import com.lowagie.text.pdf.PdfContentByte;import com.lowagie.text.pdf.PdfWriter; /** * Handles actually drawing of the notched box to a file.  This class passes everything around * in millimeters until it actually draws it at the low level.  It renders a files like this: * <pre> *               ---------- *               |  w x d | *               ---------- *               ---------- *               |  w x h | *               |        | *               ---------- *    ---------  ----------  --------- *    | d x h |  |  w x d |  | d x h | *    ---------  ----------  --------- *               ---------- *               |  w x h | *               |        | *               ---------- * </pre> *  * <p> * Modified at the Champaign Urbana Community Fab Lab (CUCFL).   * Added options to suppress the text box, set the line width to .001 in (for Epilog),  * use a compact layout, and use portrait or landscape layout. *   * @author rahulb */public class Renderer {	// how many millimeters in one inch	static final float MM_PER_INCH = 25.4f;	// how many inches in one millimeter    static final float INCH_PER_MM = 0.0393700787f;    // the standard display DPI of the pdf (not the same as printing resolution to a pdf)    static final float DPI = 72.0f;    // the PDF document created    private Document doc;    // the writer underneath the PDF document, which we need to keep a reference to    private PdfWriter docPdfWriter;    // the path that we are writing the file to    private String filePath;         static boolean doText = false;  // print/don't print tex message on drawing [CUCFL]        static boolean setLW = true; // set line width to .00i in. for Epilog laser [CUCFL]    static float lw = (float)0.09; // .001 in. is .01 pixels  [CUCFL]    /**     * Public method to render and save a box.     *       * @param filePath			the full absolute path to save the file to     * @param fileName          just the name at the end of the path     * @param mmWidth			the width of the box in millimeters     * @param mmHeight			the height of the box in millimeters     * @param mmDepth			the depth of the box in millimeters     * @param mmThickness		the thickness of the material in millimeters     * @param mmCutWidth		the width of the laser beam     * @param mmNotchLength		the length of the notch to use to hold the box together     * @param drawBoundingBox	draw an outer edge with a dimension (for easier DXF import)     * @param specifiedInInches the user specified the box in inches?     * @param noText            [CUCFL] suppress the text box     * @param epiloglinewidth   [CUCFL] set lines to .001 inch, compatible with Epilog laser     * @param compact           [CUCFL] try to layout pieces in compact arrangement, to reduce wasted material     * @param portrait          [CUCFL} adjust layout, true = 'portrait mode', false = 'landscapte'     *     * @throws DocumentException     * @throws IOException      */    public static void render(String filePath,String fileName,double mmWidth,double mmHeight,    		double mmDepth,double mmThickness, double mmCutWidth,double mmNotchLength,    		boolean drawBoundingBox,boolean specifiedInInches, boolean noText, boolean epiloglinewidth,     		boolean compact, boolean portrait)     		throws DocumentException, IOException {    	Renderer myRenderer = new Renderer(filePath);    	myRenderer.drawAllSides(mmWidth,mmHeight,mmDepth,mmThickness,mmCutWidth,mmNotchLength,    			drawBoundingBox,specifiedInInches,fileName,    			noText,epiloglinewidth,compact,portrait);  // add params [CUCFL]    	myRenderer.closeDoc();    }    	/**	 * Create a new renderer (doesn't actually do anything)	 * @param pathToSave	the full absolute path to save the file to	 */	private Renderer(String pathToSave){    	filePath = pathToSave;    }        /**     * Create the document to write to (needed before any rendering can happen).     * @param widthMm	the width of the document in millimeters     * @param heightMm	the height of the document in millimeters     * @param fileName  the name of the file to save     * @throws FileNotFoundException     * @throws DocumentException     */    private void openDoc(float widthMm,float heightMm,String fileName) throws FileNotFoundException, DocumentException{		float docWidth = widthMm*DPI*INCH_PER_MM;		float docHeight = heightMm*DPI*INCH_PER_MM;		    	doc = new Document(new Rectangle(docWidth,docHeight));		docPdfWriter = PdfWriter.getInstance(doc,new FileOutputStream(filePath));		String appNameVersion = BoxMakerConstants.APP_NAME+" "+BoxMakerConstants.VERSION;		doc.addAuthor(appNameVersion);		doc.open();		// [CUCFL] added option to suppress this text if it gets in the way		if (doText) {			doc.add(new Paragraph(                "Produced by "+BoxMakerConstants.APP_NAME+" "+BoxMakerConstants.VERSION+"\n"+                "  on "+new Date()+"\n"+BoxMakerConstants.WEBSITE_URL )		);		}    }    /**     * Draw a bounding box around the whole thing.     *      * @param margin	the offset to draw the box (in millimeters)     * @param widthMM	the width of the box to draw (in millimeters)     * @param heightMM	the height of the box to draw (in millimeters)     * @throws DocumentException      */    private void drawBoundingBox(float margin,float widthMM, float heightMM, boolean specifiedInInches)         throws DocumentException {    	drawBoxByMm(margin, margin, widthMM, heightMM);		if(specifiedInInches) {            doc.add(new Paragraph("Bounding box (in): "+widthMM*INCH_PER_MM+" x "+heightMM*INCH_PER_MM));		} else {		    doc.add(new Paragraph("Bounding box (mm): "+widthMM+" x "+heightMM));		}	}    /**     * Close up the document (writing it to disk)     */    private void closeDoc(){		doc.close();    	    }    	/**	 * Math utility function	 * @param numd	a number	 * @return		the closest odd number to the one passed in	 */	private static int closestOddTo(double numd){		int num=(int) (numd+0.5);		if(num % 2 == 0) return num-1;		return num;    }				    /**     * Actually draw all the faces of the box     *      * <p>[CUCFL] Reorganized to support alternative layouts in the drawing.     *      * @param mmWidth			the width of the box in millimeters     * @param mmHeight			the height of the box in millimeters     * @param mmDepth			the depth of the box in millimeters     * @param mmThickness		the thickness of the material in millimeters     * @param mmCutWidth		the width of the laser beam     * @param mmNotchLength		the length of the notch to use to hold the box together     * @param drawBoundingBox 	draw an outer edge with a dimension (for easier DXF import)     * @param specifiedInInches the user specified the box in inches?     * @param fileName          the name of the file to write     * @param noText            [CUCFL] suppress the text box     * @param epiloglinewidth   [CUCFL] set lines to .001 inch, compatible with Epilog laser     * @param compact           [CUCFL] try to layout pieces in compact arrangement, to reduce wasted material     * @param doportrait          [CUCFL} adjust layout, true = 'portrait mode', false = 'landscapte'     *     * @throws DocumentException     * @throws IOException      */    public void drawAllSides(double mmWidth,double mmHeight,double mmDepth,double mmThickness,			    double mmCutWidth,double mmNotchLength, boolean drawBoundingBox,			    boolean specifiedInInches, String fileName, boolean noText, boolean epiloglinewidth, 	    		boolean compact, boolean doportrait)     		throws DocumentException, IOException{    			float width =  (float) mmWidth;		float height =  (float) mmHeight;		float depth =  (float) mmDepth;		float thickness =  (float) mmThickness;		float notchLength =  (float) mmNotchLength;		float cutwidth = (float) mmCutWidth;		setLW = epiloglinewidth;				// enlarge the box to compensate for cut width		width+=cutwidth;		height+=cutwidth;		depth+=cutwidth;			//figure out how many notches for each side, trying to make notches about the right length.		int numNotchesW = closestOddTo(width / notchLength);		int numNotchesH = closestOddTo(height / notchLength);		int numNotchesD = closestOddTo(depth / notchLength);				// compute exact notch lengths		float notchLengthW = width / (numNotchesW);		float notchLengthH = height / (numNotchesH);		float notchLengthD = depth / (numNotchesD);			//and compute the new width based on that (should be a NO-OP)		float margin=10+cutwidth;		width = numNotchesW*notchLengthW;		height = numNotchesH*notchLengthH;		depth = numNotchesD*notchLengthD;					//initialize the eps file		float boxPiecesWidth = (depth*2+width);		// based on layout of pieces		float boxPiecesHeight = (height*2+depth*2); // based on layout of pieces		if (compact) {			// [CUCFL]  calculate the overall dimensions for compact layout, 'portrait' or ' landscape'.			if (doportrait) {				if (width > depth) {					boxPiecesWidth = width * 2;				} else {					boxPiecesWidth = depth * 2;				}				boxPiecesHeight = height * 2 + depth;			} else {				if (height > depth) {					boxPiecesHeight = height * 2;				} else {					boxPiecesHeight = depth * 2;				}				boxPiecesWidth = width * 2 + depth;			}							openDoc((float) (boxPiecesWidth+margin*4),(float) (boxPiecesHeight+margin*4),fileName);		} else {			// the original, default layout			openDoc((float) (boxPiecesWidth+margin*4),(float) (boxPiecesHeight+margin*5),fileName);		}				if (!noText) {			// original code to output text box	        if(specifiedInInches) {	            doc.add(new Paragraph("Width (in): "+width*INCH_PER_MM));	            doc.add(new Paragraph("Height (in): "+height*INCH_PER_MM));	            doc.add(new Paragraph("Depth (in): "+depth*INCH_PER_MM));	            doc.add(new Paragraph("Thickness (in): "+thickness*INCH_PER_MM));	            doc.add(new Paragraph("Notch Length (in): "+notchLength*INCH_PER_MM));	            doc.add(new Paragraph("Cut Width (in): "+cutwidth*INCH_PER_MM));        	        } else {	            doc.add(new Paragraph("Width (mm): "+width));	            doc.add(new Paragraph("Height (mm): "+height));	            doc.add(new Paragraph("Depth (mm): "+depth));	            doc.add(new Paragraph("Thickness (mm): "+thickness));	            doc.add(new Paragraph("Notch Length (mm): "+notchLength));	            doc.add(new Paragraph("Cut Width (mm): "+cutwidth));        	        }		}		if(drawBoundingBox) drawBoundingBox(margin,boxPiecesWidth+margin*2,boxPiecesHeight+margin*3,specifiedInInches);				// [CUCFL] generalize this calculation, to enable alternative layouts.		// [CUCFL] put the corners in an array, which can be reordered.		float xo[] = new float[6];		float yo[] = new float[6];				if (compact) {			// [CUCFL]  compute the corners of a compact layout, either portrait or landscape					if (doportrait) {				xo[0] = margin;  // W x H front				yo[0] = margin; 				xo[1] = width + margin*2;  // W x H back				yo[1] = margin;				xo[2] = margin; //height + margin * 2;  // W X D				yo[2] = height + margin*2;				xo[3] = depth + margin *2;  // W x D				yo[3] = height + margin*2;				xo[4] = margin;  // H x D				yo[4] = height*2+margin*3;				xo[5] = width + margin*2; // W x D				yo[5] = height*2+margin*3; //depth + margin*2;			} else {				yo[0] = margin;  // W x H front				xo[0] = margin; 				yo[1] = height + margin*2;  // W x H back				xo[1] = margin;				yo[2] = margin; //height + margin * 2;  // W X D				xo[2] = width + margin*2;				yo[3] = height + margin *2;  // W x D				xo[3] = width + margin*2;				yo[4] = margin;  // H x D				xo[4] = width + depth+ +margin*3;				yo[5] = depth + margin*2; // W x D				xo[5] = width + depth+ +margin*3; //depth + margin*2;			}					} else {			// This is the original, non-compact layout			// Code is reorganized, but result is same [CUCFL]			xo[0] = depth + margin*2; // W x H			yo[0] = margin;			xo[1] = depth + margin*2;			yo[1] = height + depth+ margin*3;			xo[2] = margin;			yo[2] = height + margin*2;			xo[3] = depth + width + margin*3;			yo[3] = height + margin*2;			xo[4] = depth + margin*2;			yo[4] = height + margin*2;			xo[5] = depth + margin*2;			yo[5] = height*2 + depth + margin*4;		}				//start the drawing phase		// [CUCFL] March through the array of corners. This is gives the same result as the original if not compact.		float xOrig = 0;		float yOrig = 0;			// compensate for the cut width (in part) by increasing mwidth (eolson)		// no, don't do that, because the cut widths cancel out. (eolson)		//	    mwidth+=cutwidth/2; 		//1. a W x H side (the back)		xOrig = xo[0];		yOrig = yo[0];		/// draw label: "Back"		drawHorizontalLine(xOrig,yOrig,notchLengthW,numNotchesW,thickness,cutwidth/2,false,false);					//top		drawHorizontalLine(xOrig,yOrig+height-thickness,notchLengthW,numNotchesW,thickness,cutwidth/2,true,false);	//bottom		drawVerticalLine(xOrig,yOrig,notchLengthH,numNotchesH,thickness,cutwidth/2,false,false);					//left		drawVerticalLine(xOrig+width-thickness,yOrig,notchLengthH,numNotchesH,thickness,-cutwidth/2,false,false);	//right		// [CUCFL] label the pieces		putTextMM(xOrig+thickness*2,yOrig+thickness*2,"Back");		// 2. a W x H side (the front)		xOrig = xo[1];		yOrig = yo[1];		drawHorizontalLine(xOrig,yOrig,notchLengthW,numNotchesW,thickness,cutwidth/2,false,false);					//top		drawHorizontalLine(xOrig,yOrig+height-thickness,notchLengthW,numNotchesW,thickness,cutwidth/2,true,false);	//bottom		drawVerticalLine(xOrig,yOrig,notchLengthH,numNotchesH,thickness,cutwidth/2,false,false);					//left		drawVerticalLine(xOrig+width-thickness,yOrig,notchLengthH,numNotchesH,thickness,-cutwidth/2,false,false);	//right		putTextMM(xOrig+thickness*2,yOrig+thickness*2,"Front"); // [CUCFL]		//3. a D x H side (the left side)		xOrig = xo[2];		yOrig = yo[2]; 		drawHorizontalLine(xOrig,yOrig,notchLengthD,numNotchesD,thickness,cutwidth/2,false,false);					//top		drawHorizontalLine(xOrig,yOrig+height-thickness,notchLengthD,numNotchesD,thickness,cutwidth/2,true,false);	//bottom		drawVerticalLine(xOrig,yOrig,notchLengthH,numNotchesH,thickness,cutwidth/2,false,false);					//left		drawVerticalLine(xOrig+depth-thickness,yOrig,notchLengthH,numNotchesH,thickness,-cutwidth/2,false,false);	//right		putTextMM(xOrig+thickness*2,yOrig+thickness*2,"Left"); // [CUCFL]		//4. a D x H side (the right side)		xOrig = xo[3];		yOrig = yo[3];		drawHorizontalLine(xOrig,yOrig,notchLengthD,numNotchesD,thickness,cutwidth/2,false,false);					//top		drawHorizontalLine(xOrig,yOrig+height-thickness,notchLengthD,numNotchesD,thickness,cutwidth/2,true,false);	//bottom		drawVerticalLine(xOrig,yOrig,notchLengthH,numNotchesH,thickness,cutwidth/2,false,false);					//left		drawVerticalLine(xOrig+depth-thickness,yOrig,notchLengthH,numNotchesH,thickness,-cutwidth/2,false,false);	//right		putTextMM(xOrig+thickness*2,yOrig+thickness*2,"Right");  // [CUCFL]		//5. a W x D side (the bottom)		xOrig = xo[4];		yOrig = yo[4];		drawHorizontalLine(xOrig,yOrig,notchLengthW,numNotchesW,thickness,-cutwidth/2,true,true);				//top		drawHorizontalLine(xOrig,yOrig+depth-thickness,notchLengthW,numNotchesW,thickness,-cutwidth/2,false,true);	//bottom		drawVerticalLine(xOrig,yOrig,notchLengthD,numNotchesD,thickness,-cutwidth/2,true,true);				//left		drawVerticalLine(xOrig+width-thickness,yOrig,notchLengthD,numNotchesD,thickness,-cutwidth/2,false,true);	//right		putTextMM(xOrig+thickness*2,yOrig+thickness*2,"Bottom");  //[CUCFL]		//6. a W x D side (the top)		xOrig = xo[5];		yOrig = yo[5];		drawHorizontalLine(xOrig,yOrig,notchLengthW,numNotchesW,thickness,-cutwidth/2,true,true);				//top		drawHorizontalLine(xOrig,yOrig+depth-thickness,notchLengthW,numNotchesW,thickness,-cutwidth/2,false,true);	//bottom		drawVerticalLine(xOrig,yOrig,notchLengthD,numNotchesD,thickness,-cutwidth/2,true,true);				//left		drawVerticalLine(xOrig+width-thickness,yOrig,notchLengthD,numNotchesD,thickness,-cutwidth/2,false,true);	//right		putTextMM(xOrig+thickness*2,yOrig+thickness*2,"Top"); // [CUCFL]		    }	/**     * Draw one horizontal notched line     * @param x0			x-coord of the starting point of the line (lower left corner)      * @param y0			y-coord of the starting point of the line (lower left corner)     * @param notchWidth	the width of each notch to draw in millimeters     * @param notchCount	the number of notches to draw along the edge     * @param notchHieght	the height of the notches to draw (the material thickness)     * @param cutwidth		the width of the laser beam to compensate for     * @param flip			should the first line (at x0,y0) be out or in     * @param smallside		should this stop short of the full height or not     */    private void drawHorizontalLine(float x0,float y0, float notchWidth,    		int notchCount,float notchHieght /*material tickness*/,    		float cutwidth,boolean flip,boolean smallside){    	float x=x0,y=y0;    			for (int step=0;step<notchCount;step++)		    {			y=(((step%2)==0)^flip) ? y0 : y0+notchHieght;				if(step==0){		//start first edge in the right place			    if(smallside) drawLineByMm(x+notchHieght,y,x+notchWidth+cutwidth,y);			    else drawLineByMm(x,y,x+notchWidth+cutwidth,y);			} else if (step==(notchCount-1)){	//shorter last edge			    drawLineByMm(x-cutwidth,y,x+notchWidth-notchHieght,y);			} else if (step%2==0) {			    drawLineByMm(x-cutwidth,y,x+notchWidth+cutwidth,y);		    } else {			    drawLineByMm(x+cutwidth,y,x+notchWidth-cutwidth,y);		    }						if (step<(notchCount-1)){			    if (step%2==0){					drawLineByMm(x+notchWidth+cutwidth,y0+notchHieght,x+notchWidth+cutwidth,y0);			    } else {					drawLineByMm(x+notchWidth-cutwidth,y0+notchHieght,x+notchWidth-cutwidth,y0);			    }			}						x=x+notchWidth;		}			    }    /**     * Draw one vertical notched line     * @param x0			x-coord of the starting point of the line (lower left corner)      * @param y0			y-coord of the starting point of the line (lower left corner)     * @param notchWidth	the width of each notch to draw in millimeters     * @param notchCount	the number of notches to draw along the edge     * @param notchHieght	the height of the notches to draw (the material thickness)     * @param cutwidth		the width of the laser beam to compensate for     * @param flip			should the first line (at x0,y0) be out or in     * @param smallside		should this stop short of the full height or not     */    private void drawVerticalLine(float x0,float y0, float stepLength,int numSteps,    		float mlength,float cutwidth,boolean flip,boolean smallside){		float x=x0,y=y0;			for (int step=0;step<numSteps;step++) {			x=(((step%2)==0)^flip) ? x0 : x0+mlength;				if (step==0) {				if(smallside) drawLineByMm(x,y+mlength,x,y+stepLength+cutwidth);			    else drawLineByMm(x,y,x,y+stepLength+cutwidth);			} else if (step==(numSteps-1)) {			    //g.moveTo(x,y+cutwidth); g.lineTo(x,y+stepLength); g.stroke();				if(smallside) drawLineByMm(x,y-cutwidth,x,y+stepLength-mlength);			    else drawLineByMm(x,y-cutwidth,x,y+stepLength); 			} else if (step%2==0) {			    drawLineByMm(x,y-cutwidth,x,y+stepLength+cutwidth);			} else {			    drawLineByMm(x,y+cutwidth,x,y+stepLength-cutwidth);			}						if (step<(numSteps-1)) {			    if (step%2==0) {			    	drawLineByMm(x0+mlength,y+stepLength+cutwidth,x0,y+stepLength+cutwidth);			    } else {			    	drawLineByMm(x0+mlength,y+stepLength-cutwidth,x0,y+stepLength-cutwidth);			    }			}			y=y+stepLength;		}    }            /**     * [CUCFL] Put short message at the specified location in the drawing.     * @param fromXmm		x-coord of the starting point of the line (lower left corner)      * @param fromYmm		y-coord of the starting point of the line (lower left corner)     * @param String		the message     *      * @throws DocumentException     * @throws IOException       */    private void putTextMM(float fromXmm,float fromYmm,String text) throws DocumentException, IOException  {    	PdfContentByte cb = docPdfWriter.getDirectContent();    			float x0 = DPI*fromXmm*INCH_PER_MM;		float y0 = DPI*fromYmm*INCH_PER_MM;    			cb.setFontAndSize(BaseFont.createFont(BaseFont.HELVETICA, BaseFont.WINANSI, false), /*24*/12);		cb.beginText();		cb.setTextMatrix(x0,y0);        cb.showText(text);        cb.endText();        cb.stroke();    }    /**     * Low-level function to draw lines     * @param fromXmm	start x pos on age (in millimeters)     * @param fromYmm	start y pos on age (in millimeters)     * @param toXmm		end x pos on age (in millimeters)     * @param toYmm		end y pos on age (in millimeters)     */    private void drawLineByMm(float fromXmm,float fromYmm,float toXmm,float toYmm){    	PdfContentByte cb = docPdfWriter.getDirectContent();    	    	// [CUCFL] global parameter 'setLW overrides the line width    	if (setLW) {    		cb.setLineWidth(lw);    	} else {    		cb.setLineWidth(0f);    	}		float x0 = DPI*fromXmm*INCH_PER_MM;		float y0 = DPI*fromYmm*INCH_PER_MM;    	cb.moveTo(x0,y0);    	float x1 = DPI*toXmm*INCH_PER_MM;    	float y1 = DPI*toYmm*INCH_PER_MM;    	cb.lineTo(x1, y1);    	cb.stroke();    }    /**     * Draw a rectangle with based on the endpoints passed in     * @param fromXmm     * @param fromYmm     * @param toXmm     * @param toYmm     */    private void drawBoxByMm(float fromXmm,float fromYmm,float toXmm,float toYmm){     	PdfContentByte cb = docPdfWriter.getDirectContent();     	     // [CUCFL] global parameter 'setLW overrides the line width     	if (setLW) {    		cb.setLineWidth(lw);    	} else {    		cb.setLineWidth(0f);    	}				float x0 = DPI*fromXmm*INCH_PER_MM;		float y0 = DPI*fromYmm*INCH_PER_MM;    	float x1 = DPI*toXmm*INCH_PER_MM;    	float y1 = DPI*toYmm*INCH_PER_MM;    	cb.rectangle(x0, y0, x1, y1);    	cb.stroke();    }    /**     * Test harness to just render a box quickly     * @param args     */    public static void main(String[] args){		try {			Renderer.render("temp.pdf","temp.pdf",8*MM_PER_INCH,3*MM_PER_INCH,5*MM_PER_INCH,					0.1875*MM_PER_INCH,0,0.5625*MM_PER_INCH,true,false,					false,false,false,true); // [CUCFL] add params		} catch (FileNotFoundException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (DocumentException e) {			// TODO Auto-generated catch block			e.printStackTrace();		} catch (IOException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}    }    }
